Classes e Objetos

Object:
- classe generica, toda classe eh um subconjunto da classe Object
- possue os seguintes medotos:
	* GetType - retorna o tipo do objeto
	* Equals - compara se o objeto eh igual ao outro
	* GetHashCode - retorna um codigo hash do objeto
	* ToString - converte o objeto para string

-> override string ToString(){}
	- metodo que vai retornar uma string de nossa escolha sempre que o objeto for impresso na tela. 
	- fazemos isso para modularizar uma chamada, uma acao envolvendo aquele objeto

	-> StringBuilder sb = new StringBuilder();
	permite criarmos string mais complexas sem perder o rendimento instanciando sempre novas strings
	- sb.Append(conteudo); : adiciona o conteudo no StringBuilder
	- sb.AppendLine(conteudo); : adiciona o conteudo com quebra de linha no StringBuilder

-> GetHashCode e Equals:
	- operacoes da classe Object utilizadas para comparar se um objeto é igual a outro
	- Equals: lento, resposta 100%
	- GetHashCode: rapido, porem resposta positiva nao é 100%
	- os tipos pre definidos ja possuem implementacao para essas operacoes. Classes e structs personalizadas precisam sobrepo-las.

*-> Equals:
	- Metodo que compara se um objeto é igual ao outro retornando true ou false.
	- Ex.:
		string a = "Maria";
		string b = "Alex";
		Console.WriteLine(a.Equals(b)); // false

*-> GetHashCode:
	- Metodo que retorna um numero inteiro representando um codigo gerado a partir das informacoes do objeto
	- Ex.:
		string a = "Maria";
		string b = "Alex";
		Console.WriteLine(a.GetHashCode()); // 098102378167
		Console.WriteLine(b.GetHashCode()); // -891923861233

	- Dois objetos iguais SEMPRE teram HashCodes iguais
	- Porem se o HashCode de dois objetos forem iguais, MUITO PROVAVELMENTE os objetos sao iguais (pode haver colisao)
	- Muito comum utilizar o GetHashCode para fazer comparacoes RAPIDAS e depois certificar que a comparacao esta certa com o Equals.

*-> Exemplos de GetHashCode e Equals personalizados:

	public override bool Equals(object? obj)
	{
    		if(!(obj is Client))
    		{
        		return false;
    		}

    		Client other = obj as Client;

    		return Email.Equals(other.Email);
	}

	public override int GetHashCode()
	{
    		return Email.GetHashCode();
	}

- Diferenca entre '==' e 'Equals':
	* == compara a referencia do ponteiro na memoria
	* Equals compara a partir de uma logica definida
	* Assim dois objetos podem sem diferentes pelo '==' porem iguais pelo 'Equals'

/////////////////////////////////////////////////////////////////////////////////////
Modificadores de Acesso:
		     |	propria classe 	subclasses do  	classes do   subclasses fora   classes fora	
		     |			  assembly       assembly      do assembly      do assembly
-----------------------------------------------------------------------------------------------------
- public	     |	       x              x              x              x                 x 
- protected internal |	       x              x              x              x                 
- internal           |	       x              x              x              
- protected          |	       x              x                             x
- private protected  |	       x              
- private            | 	       x  

/////////////////////////////////////////////////////////////////////////////////////
Construtores:

- podemos iniciar valores das propriedades de uma classe quando instanciada com uma sintaxe alternativa e nao necessariamente necessitando de um construtor daquela classe.
- so funciona se existir um construtor padrao sem atribuicao alguma na classe
	Classe Produto: (nome, valor, quantidade)

	Produto p = new Produto {
		nome = "TV",
		valor = 800,
		quantadade = 2
	};

ou
	Produto p = new Produto() {
		nome = "TV",
		valor = 800,
		quantadade = 2
	};

/////////////////////////////////////////////////////////////////////////////////////
Objetos Anonimos:
- podemos instanciar objetos anonimos em qualquer parte do projeto.
- sao objetos que nao pertencem a classe nenhuma criada no projeto.
- podemos inserir valores no objeto na instanciacao
- Ex.:
	new { x.Name, x.Price, CategoryName = x.Category.Name }

	// aqui ele vai receber como propriedades o Name, Price e o Category.Name com o ‘apelido’ de CategoryName;

/////////////////////////////////////////////////////////////////////////////////////

Encapsulamento:

- Membros private:
	-> forma 'manual' de implementar (pouco utilizada)
- utilizamos membros private quando queremos reduzir a capacidade de manipulacao de algumas propriedades fora da classe.
- metodos sao criados para poder acessar ou alterar os valores das propriedades private:
	Get...(){} -> retorna o valor
	Set...(){} -> 'seta', altera o valor
- utilizar metodos para fazer essas operacoes permite que possamos limitar o acesso a  aquela propriedades ou ate definir outras condicoes dentro dos metodos.


-> Properties:
- sao formas de tratar uma variavel/atributo da classe como uma propriedade para utilizar as funcoes de get e set de forma mais amigavel (mais utilizada)
	public _tipo_ _Nome_{
		get {}
		set {}
	}
	
	- dentro das chaves estarao as funcoes para retornar ou alterar valores das propriedades/variaveis
	- para utilizar valores que serao passados como parametro para a propriedade e depois armazenados em alguma varaivel utilizamos 'value' para mexer com o parametro passado

-> AutoProperties:
- podemos declarar as propriedades de get e set, caso nao tenham nenhuma instrucao mais elaborada, diretamente na declaracao da variavel.
	public string Nome {get; set;}
	public double Prco {get; private set;}

	- a utilizacao do 'private set' indica que o valor daquela variavel nao pode ser alterado por outro arquivo ou classe, apenas com isntrucoes da propria classe

/////////////////////////// Tipo de classes /////////////////////////

-> sealed:

- Utilizado em Classes: evita que a classe seja herdada
	Namespace Course {
		sealed class SavingsAccount { (...)

- Utilizado em Metodos: evita que metodos sobreescritos sejam sobreescritos novamentente em outras classes derivadas a esta.
	-> so funciona com metodos que ja foram sobreescritos de uma superclasse.

-> abstracts:

- Utilizando em Classes:
* nao podem ser instanciadas.
* uma forma de garantir heranca total: somente classes nao abstratas podem ser instanciadas, mas nunca a superclasse abstrata
	Namespace Course {
		abstract class Account { (...)

	Notacao UML: italico

- Utilizando em Metodos:
* metodos que nao possuem implementacao
* metodos precisam ser abstratos quando a sua classe eh generica demais para implementa-los
* se uma classe possuir pelo menos um metodo abstrato, entao esta classe tambem eh abstrata
* Notacao UML: italico
	-> para implementar metodos abstratos em outras classes utilizados o 'override', como uma forma de heranca

	